# Memo: Xray's real-time version control system

Memo is an experimental real-time conflict-free version control system. It is currently work-in-progress. Eventually, our goal is to enable Memo by default when editing via the Xray editor, but also allow Memo to be integrated with other text editors via a shared-library or a standalone server that communicates over local sockets.

The sections that follow in this document are totally aspirational and subject to change as we implement more and more features.

## Overview

When working with Git, you commit snapshots of your repository to a branch, then manually synchronize your copy of that branch with a remote replica by pulling and pushing commits. Memo branches are similar to Git branches, but they are automatically persisted on every edit and are continuously synchronized across all replicas in real-time without requiring manual conflict resolution.

Real-time change synchronization means that instead of waiting for changes to be committed and pushed to GitHub, cloud-based services can interact with the state of a repository as the code is being actively being written. For example, a service like Code Climate could perform incremental analysis on every branch of an Memo repository as it changes, inserting annotations into the repository that are be interpreted by client-side tooling. The ability for any replica to perform writes without risk of conflicts means that a cloud-based service could also perform edits such as code formatting.

Memo branches persist every change as it occurs, allowing a specific moments in the editing history to be identified with a version vector. This allows developers to write code for extended sessions without committing, then scrub the history to identify relevant checkpoints in their work after the fact. These checkpoints could also be identified automatically via analysis of the edit history. Fine-grained versioning means that any state of the code can be deployed into a development environment or a staging server without the ceremony of a commit. Just make some edits and click "play" to try them out.

Memo can be used as a standalone version control system, but it is also designed to interoperate smoothly with Git, meaning that an Memo repository can also be a Git repository. Memo branches are aware of the current Git branch, and Memo automatically maps Git commit SHAs to Memo version vectors as commits are created. If Memo detects that the user has checked out a different Git commit, it automatically updates the Memo branch to the appropriate version in the Memo history and replicates the check-out to all the branch's replicas.

## Conceptual model

### Operation-based representation

The repository is modeled as an operation-based conflict-free replicated data type (or CRDT) whose state is derived from a set of commutative operations.

#### Unique ids and version vectors

Globally-unique ids are a fundamental primitive of our data structures. Each replica is assigned a version 4 UUID, which is a randomly generated 128-bit integer. This is called the *replica id*. Each replica is then associated with an unsigned 64-bit counter which is used to produce *sequence numbers*. When a replica needs to generate a unique id, it combines its unique replica id with a sequence number generated via the counter.

Basing ids on an incrementing sequence number means that any two operations generated on a single replica can be ordered. To identify a specific moment in time given a set of operations generated on multiple replicas, we use a *version vector*. For every replica that produced an operation in the set, the version vector includes a mapping from that replica's id to a specific sequence number.

For example, lets use letters instead of 128-bit integers to represent replica ids. Imagine that replicas A, B, and C produce 10, 5, and 7 operations respectively. That means our operation set contains operations with ids A.1, A.2, A.3, ..., B.1, B.2.., C.1, ..., etc. We can identify a specific subset of these operations with the version vector {A: 7, B: 4, C: 5}. In practice, due to causal dependencies between operations, not all version vectors refer to valid repository states, but all valid repository states can be identified by a version vector.

#### File system operations

For this description, we'll refer to files and directories as "nodes". Each node is associated with a unique identifier that is generated by the replica that created that node. Each node is also associated with *last-writer-wins registers* containing the id of the node's parent directory and the node's name. These two values can be used to derive the node's full path.

A last-writer wins register is a simple CRDT that allows a single value to be concurrently assigned by multiple replicas. We associate registers and their update operations with Lamport timestamps to ensure causal ordering is respected. This means that if a replica observes another replica updating a register's value and then performs an update itself, its assignment will win. In the case of concurrent register updates, we break ties arbitrarily based on the Lamport timestamp and then replica id if the timestamps are equal. This ensures the register is eventually consistent across all replicas.

A node is also associated with a *deletions set*, which contains the unique ids of zero or more deletion operations. If the deletions set is non-empty, the node should be considered deleted.

This set of primitives allows a set of files to be created, moved, renamed, and deleted on each replica without the need for manual conflict resolution.

#### Text file operations

If a file system node is associated with a text file, its contents are described by edit operations. Each insertion of text, be it a single character or a multi-kilobyte block, is associated with a unique identifier. Subsequently, that identifier can be combined with an offset to describe a unique position in the document. Deletions can be expressed as an (id, offset) describing the start and end of the deleted range along with a version vector expressing the subset of operations between these two points that were visible at the time the deletion was generated.

### Timelines

To support branching, the repository's operations are grouped into independent timelines. Each timeline is uniquely identified across all replicas, and every operation is associated with a single timeline on its initial broadcast. We can identify a specific *repository version* by combining a unique timeline id with a version vector describing a specific moment along that timeline.

When a repository is initially created, it has a single timeline. Additional timelines can be created that diverge from existing timelines. These additional timelines are associated with a *base version* that describes their starting point. All operations in the base version are assumed to be included in any version that references the additional timeline's id.

### Indexing

Operations represent the *essential state* of the repository, meaning that any repository version can always be derived from the set of operations it contains. However, to improve performance, each timeline is associated with a *timeline index* that allows the combined impact of its operations to be efficiently queried.

An timeline index is the combination of multiple fully-persistent data structures that represent the state of the file tree and the contents of every file within it. As operations flow into a replica, the index is updated in memory and the operations are temporarily persisted to disk. Periodically, a snapshot of the index is persisted to disk and the operations contained by the written version are deleted from storage.

The file system and individual text files are both indexed via persistent B-trees. To index the file system, we embed a lexicographically-sorted depth-first traversal of all files within a persistent B-tree. For text files, we maintain a tree of insertion fragments and a set of trees split trees tracking where each insertion has been split.

Long-term storage is implemented with an off-the-shelf key-value database. Each node of our persistent B-tree is written to the database only once and assigned an identifier.

### Branching


## Git Interop

## Synchronization

### Partial synchronization

## Command line interface

When using Memo via the Xray editor, command-line interaction should not be required, but CLI serves as a good reference to the high-level operations supported by ERA. All repository operations are performed through the `memo` command.

* `memo init` Create an Memo repository in the current directory. Memo will create a database file named `.memo` in the current directory and add an entry for it to the `.gitignore` if the current directory is a Git repository. It will then populate the database based on the current state of the file system and create a default `master` branch in which to store edits.

* `memo remote add <name> <url>` Register a remote Memo repository and allow the current repository to check out branches from that repository.

* `memo sync [--force] [<remote>]` Synchronize the repository with the current state of the file system after disconnected operation. If this is a Git repository and the specified remote is reachable over the network, Memo first attempts to fetch history mapping to the current Git `HEAD`. Once the fetch completes, Memo history is synthesized for any Git commits that aren't present in the database. If the remote is unreachable, synchronization may fail, placing the current branch into *disconnected mode*, described later in the document.

* `memo publish [<remote>] [<local-branch>[:<remote-branch>]]` Send the current state of a local branch to a remote replica, along with all future operations. If no `<local-branch>` is specified, it is assumed to be the current branch. If no `<remote>` is specified, it is assumed to be `origin`.

* `memo unpublish [<remote>] [<local-branch>]` Stop sending operations for a local branch to a specific replica. If no `<local-branch>` is specified, it is assumed to be the current branch. If no `<remote>` is specified, it is assumed to be `origin`.

* `memo checkout [<remote>/]<branch>` Start editing a branch. This fetches the branch's current state and subscribes to all future operations. Any edits will be broadcast to other replicas until `memo unpublish` is run.

* `memo checkout -b <branch>` Create a new branch based on the state of the current branch.

* `memo reset <version>` Switch the current branch to the specified state in the repository and replicate this change out to other replicas.

* `memo merge <branch>` Merge the specified branch into the current branch. This only succeeds if the specified branch shares a common ancestor with the current branch.

## Xray integration

Xray is designed around Memo, with the goal of being Memo's ideal text editor implementation. When Xray opens a folder, it looks for an `.memo` file at the folder's root. If one is detected, Xray automatically synchronizes the repository with `origin`. This synchronization is usually quick and often instant, but in rare circumstances it may take some time. If the user attempts to edit a file before synchronization is complete, they will be offered the option to cancel the synchronization and enter *disconnected mode*, which disables certain advanced features that require the full edit history. They can also check a box to *always* abort synchronization and skip the prompt the next time they attempt to edit prior to a complete synchronization.

Once synchronization is complete (usually in a less than few seconds), the user is free to make edits, and all changes are continuously persisted into the repository. The availability of a full edit history for every buffer enables recovery to the latest state in the event of power failure, infinite, non-chronological undo, stable permalinks to logical positions in the source code, and more. If you edit the same Memo branch as another user, you will see their edits in real time as well as the location of their active cursor.

## Tasks
* [x] Update index from a depth-first traversal of an external file system
* [ ] Mirror remote operations to the local file system
* [ ] File system changes that happen in the middle of a scan
  * For example, if we scan a directory and then that same directory is moved later in the depth-first traversal before the scan completes, we would scan it again.
* [ ] Applying remote operations to an index that doesn't match the state of the file system
  * For example, a remote user adds a directory "b" inside a directory "a", but directory "a" is renamed to "c" before we can apply the result of the operation.
* [ ] Watch the file system
* [ ] Scan the file system
