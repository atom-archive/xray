// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

// struct ReplicaId, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct ReplicaId {
  first_8_bytes_: u64,
  last_8_bytes_: u64,
} // pub struct ReplicaId
impl flatbuffers::SafeSliceAccess for ReplicaId {}
impl<'a> flatbuffers::Follow<'a> for ReplicaId {
  type Inner = &'a ReplicaId;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a ReplicaId>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a ReplicaId {
  type Inner = &'a ReplicaId;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<ReplicaId>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for ReplicaId {
    type Output = ReplicaId;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const ReplicaId as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b ReplicaId {
    type Output = ReplicaId;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const ReplicaId as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl ReplicaId {
  pub fn new<'a>(_first_8_bytes: u64, _last_8_bytes: u64) -> Self {
    ReplicaId {
      first_8_bytes_: _first_8_bytes.to_little_endian(),
      last_8_bytes_: _last_8_bytes.to_little_endian(),

    }
  }
  pub fn first_8_bytes<'a>(&'a self) -> u64 {
    self.first_8_bytes_.from_little_endian()
  }
  pub fn last_8_bytes<'a>(&'a self) -> u64 {
    self.last_8_bytes_.from_little_endian()
  }
}

// struct Timestamp, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Timestamp {
  value_: u64,
  replica_id_: ReplicaId,
} // pub struct Timestamp
impl flatbuffers::SafeSliceAccess for Timestamp {}
impl<'a> flatbuffers::Follow<'a> for Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Timestamp>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Timestamp>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Timestamp {
    type Output = Timestamp;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Timestamp {
    type Output = Timestamp;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Timestamp {
  pub fn new<'a>(_value: u64, _replica_id: &'a ReplicaId) -> Self {
    Timestamp {
      value_: _value.to_little_endian(),
      replica_id_: *_replica_id,

    }
  }
  pub fn value<'a>(&'a self) -> u64 {
    self.value_.from_little_endian()
  }
  pub fn replica_id<'a>(&'a self) -> &'a ReplicaId {
    &self.replica_id_
  }
}

pub enum GlobalTimestampOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GlobalTimestamp<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GlobalTimestamp<'a> {
    type Inner = GlobalTimestamp<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GlobalTimestamp<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GlobalTimestamp {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GlobalTimestampArgs<'args>) -> flatbuffers::WIPOffset<GlobalTimestamp<'bldr>> {
      let mut builder = GlobalTimestampBuilder::new(_fbb);
      if let Some(x) = args.timestamps { builder.add_timestamps(x); }
      builder.finish()
    }

    pub const VT_TIMESTAMPS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn timestamps(&self) -> Option<&'a [Timestamp]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Timestamp>>>(GlobalTimestamp::VT_TIMESTAMPS, None).map(|v| v.safe_slice() )
  }
}

pub struct GlobalTimestampArgs<'a> {
    pub timestamps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Timestamp>>>,
}
impl<'a> Default for GlobalTimestampArgs<'a> {
    #[inline]
    fn default() -> Self {
        GlobalTimestampArgs {
            timestamps: None,
        }
    }
}
pub struct GlobalTimestampBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GlobalTimestampBuilder<'a, 'b> {
  #[inline]
  pub fn add_timestamps(&mut self, timestamps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Timestamp>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GlobalTimestamp::VT_TIMESTAMPS, timestamps);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GlobalTimestampBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GlobalTimestampBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GlobalTimestamp<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub mod buffer {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum AnchorVariant {
  Start = 0,
  Middle = 1,
  End = 2,

}

const ENUM_MIN_ANCHOR_VARIANT: i8 = 0;
const ENUM_MAX_ANCHOR_VARIANT: i8 = 2;

impl<'a> flatbuffers::Follow<'a> for AnchorVariant {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for AnchorVariant {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const AnchorVariant;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const AnchorVariant;
    unsafe { *p }
  }
}

impl flatbuffers::Push for AnchorVariant {
    type Output = AnchorVariant;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<AnchorVariant>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ANCHOR_VARIANT:[AnchorVariant; 3] = [
  AnchorVariant::Start,
  AnchorVariant::Middle,
  AnchorVariant::End
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_ANCHOR_VARIANT:[&'static str; 3] = [
    "Start",
    "Middle",
    "End"
];

pub fn enum_name_anchor_variant(e: AnchorVariant) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_ANCHOR_VARIANT[index]
}

#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum AnchorBias {
  Left = 0,
  Right = 1,

}

const ENUM_MIN_ANCHOR_BIAS: i8 = 0;
const ENUM_MAX_ANCHOR_BIAS: i8 = 1;

impl<'a> flatbuffers::Follow<'a> for AnchorBias {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for AnchorBias {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const AnchorBias;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const AnchorBias;
    unsafe { *p }
  }
}

impl flatbuffers::Push for AnchorBias {
    type Output = AnchorBias;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<AnchorBias>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_ANCHOR_BIAS:[AnchorBias; 2] = [
  AnchorBias::Left,
  AnchorBias::Right
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_ANCHOR_BIAS:[&'static str; 2] = [
    "Left",
    "Right"
];

pub fn enum_name_anchor_bias(e: AnchorBias) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_ANCHOR_BIAS[index]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum OperationVariant {
  NONE = 0,
  Edit = 1,
  UpdateSelections = 2,

}

const ENUM_MIN_OPERATION_VARIANT: u8 = 0;
const ENUM_MAX_OPERATION_VARIANT: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for OperationVariant {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for OperationVariant {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const OperationVariant;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const OperationVariant;
    unsafe { *p }
  }
}

impl flatbuffers::Push for OperationVariant {
    type Output = OperationVariant;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<OperationVariant>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_OPERATION_VARIANT:[OperationVariant; 3] = [
  OperationVariant::NONE,
  OperationVariant::Edit,
  OperationVariant::UpdateSelections
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_OPERATION_VARIANT:[&'static str; 3] = [
    "NONE",
    "Edit",
    "UpdateSelections"
];

pub fn enum_name_operation_variant(e: OperationVariant) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_OPERATION_VARIANT[index]
}

pub struct OperationVariantUnionTableOffset {}
pub enum AnchorOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Anchor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Anchor<'a> {
    type Inner = Anchor<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Anchor<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Anchor {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AnchorArgs<'args>) -> flatbuffers::WIPOffset<Anchor<'bldr>> {
      let mut builder = AnchorBuilder::new(_fbb);
      builder.add_offset(args.offset);
      if let Some(x) = args.insertion_id { builder.add_insertion_id(x); }
      builder.add_bias(args.bias);
      builder.add_variant(args.variant);
      builder.finish()
    }

    pub const VT_VARIANT: flatbuffers::VOffsetT = 4;
    pub const VT_INSERTION_ID: flatbuffers::VOffsetT = 6;
    pub const VT_OFFSET: flatbuffers::VOffsetT = 8;
    pub const VT_BIAS: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn variant(&self) -> AnchorVariant {
    self._tab.get::<AnchorVariant>(Anchor::VT_VARIANT, Some(AnchorVariant::Start)).unwrap()
  }
  #[inline]
  pub fn insertion_id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(Anchor::VT_INSERTION_ID, None)
  }
  #[inline]
  pub fn offset(&self) -> u64 {
    self._tab.get::<u64>(Anchor::VT_OFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn bias(&self) -> AnchorBias {
    self._tab.get::<AnchorBias>(Anchor::VT_BIAS, Some(AnchorBias::Left)).unwrap()
  }
}

pub struct AnchorArgs<'a> {
    pub variant: AnchorVariant,
    pub insertion_id: Option<&'a  super::Timestamp>,
    pub offset: u64,
    pub bias: AnchorBias,
}
impl<'a> Default for AnchorArgs<'a> {
    #[inline]
    fn default() -> Self {
        AnchorArgs {
            variant: AnchorVariant::Start,
            insertion_id: None,
            offset: 0,
            bias: AnchorBias::Left,
        }
    }
}
pub struct AnchorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AnchorBuilder<'a, 'b> {
  #[inline]
  pub fn add_variant(&mut self, variant: AnchorVariant) {
    self.fbb_.push_slot::<AnchorVariant>(Anchor::VT_VARIANT, variant, AnchorVariant::Start);
  }
  #[inline]
  pub fn add_insertion_id(&mut self, insertion_id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(Anchor::VT_INSERTION_ID, insertion_id);
  }
  #[inline]
  pub fn add_offset(&mut self, offset: u64) {
    self.fbb_.push_slot::<u64>(Anchor::VT_OFFSET, offset, 0);
  }
  #[inline]
  pub fn add_bias(&mut self, bias: AnchorBias) {
    self.fbb_.push_slot::<AnchorBias>(Anchor::VT_BIAS, bias, AnchorBias::Left);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AnchorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AnchorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Anchor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum SelectionOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Selection<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Selection<'a> {
    type Inner = Selection<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Selection<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Selection {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args SelectionArgs<'args>) -> flatbuffers::WIPOffset<Selection<'bldr>> {
      let mut builder = SelectionBuilder::new(_fbb);
      if let Some(x) = args.end { builder.add_end(x); }
      if let Some(x) = args.start { builder.add_start(x); }
      builder.add_reversed(args.reversed);
      builder.finish()
    }

    pub const VT_START: flatbuffers::VOffsetT = 4;
    pub const VT_END: flatbuffers::VOffsetT = 6;
    pub const VT_REVERSED: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn start(&self) -> Option<Anchor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Anchor<'a>>>(Selection::VT_START, None)
  }
  #[inline]
  pub fn end(&self) -> Option<Anchor<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Anchor<'a>>>(Selection::VT_END, None)
  }
  #[inline]
  pub fn reversed(&self) -> bool {
    self._tab.get::<bool>(Selection::VT_REVERSED, Some(false)).unwrap()
  }
}

pub struct SelectionArgs<'a> {
    pub start: Option<flatbuffers::WIPOffset<Anchor<'a >>>,
    pub end: Option<flatbuffers::WIPOffset<Anchor<'a >>>,
    pub reversed: bool,
}
impl<'a> Default for SelectionArgs<'a> {
    #[inline]
    fn default() -> Self {
        SelectionArgs {
            start: None,
            end: None,
            reversed: false,
        }
    }
}
pub struct SelectionBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> SelectionBuilder<'a, 'b> {
  #[inline]
  pub fn add_start(&mut self, start: flatbuffers::WIPOffset<Anchor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Anchor>>(Selection::VT_START, start);
  }
  #[inline]
  pub fn add_end(&mut self, end: flatbuffers::WIPOffset<Anchor<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Anchor>>(Selection::VT_END, end);
  }
  #[inline]
  pub fn add_reversed(&mut self, reversed: bool) {
    self.fbb_.push_slot::<bool>(Selection::VT_REVERSED, reversed, false);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> SelectionBuilder<'a, 'b> {
    let start = _fbb.start_table();
    SelectionBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Selection<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum EditOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Edit<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Edit<'a> {
    type Inner = Edit<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Edit<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Edit {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EditArgs<'args>) -> flatbuffers::WIPOffset<Edit<'bldr>> {
      let mut builder = EditBuilder::new(_fbb);
      builder.add_end_offset(args.end_offset);
      builder.add_start_offset(args.start_offset);
      if let Some(x) = args.lamport_timestamp { builder.add_lamport_timestamp(x); }
      if let Some(x) = args.local_timestamp { builder.add_local_timestamp(x); }
      if let Some(x) = args.new_text { builder.add_new_text(x); }
      if let Some(x) = args.version_in_range { builder.add_version_in_range(x); }
      if let Some(x) = args.end_id { builder.add_end_id(x); }
      if let Some(x) = args.start_id { builder.add_start_id(x); }
      builder.finish()
    }

    pub const VT_START_ID: flatbuffers::VOffsetT = 4;
    pub const VT_START_OFFSET: flatbuffers::VOffsetT = 6;
    pub const VT_END_ID: flatbuffers::VOffsetT = 8;
    pub const VT_END_OFFSET: flatbuffers::VOffsetT = 10;
    pub const VT_VERSION_IN_RANGE: flatbuffers::VOffsetT = 12;
    pub const VT_NEW_TEXT: flatbuffers::VOffsetT = 14;
    pub const VT_LOCAL_TIMESTAMP: flatbuffers::VOffsetT = 16;
    pub const VT_LAMPORT_TIMESTAMP: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn start_id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(Edit::VT_START_ID, None)
  }
  #[inline]
  pub fn start_offset(&self) -> u64 {
    self._tab.get::<u64>(Edit::VT_START_OFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn end_id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(Edit::VT_END_ID, None)
  }
  #[inline]
  pub fn end_offset(&self) -> u64 {
    self._tab.get::<u64>(Edit::VT_END_OFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn version_in_range(&self) -> Option<super::GlobalTimestamp<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<super::GlobalTimestamp<'a>>>(Edit::VT_VERSION_IN_RANGE, None)
  }
  #[inline]
  pub fn new_text(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Edit::VT_NEW_TEXT, None)
  }
  #[inline]
  pub fn local_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(Edit::VT_LOCAL_TIMESTAMP, None)
  }
  #[inline]
  pub fn lamport_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(Edit::VT_LAMPORT_TIMESTAMP, None)
  }
}

pub struct EditArgs<'a> {
    pub start_id: Option<&'a  super::Timestamp>,
    pub start_offset: u64,
    pub end_id: Option<&'a  super::Timestamp>,
    pub end_offset: u64,
    pub version_in_range: Option<flatbuffers::WIPOffset<super::GlobalTimestamp<'a >>>,
    pub new_text: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub local_timestamp: Option<&'a  super::Timestamp>,
    pub lamport_timestamp: Option<&'a  super::Timestamp>,
}
impl<'a> Default for EditArgs<'a> {
    #[inline]
    fn default() -> Self {
        EditArgs {
            start_id: None,
            start_offset: 0,
            end_id: None,
            end_offset: 0,
            version_in_range: None,
            new_text: None,
            local_timestamp: None,
            lamport_timestamp: None,
        }
    }
}
pub struct EditBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EditBuilder<'a, 'b> {
  #[inline]
  pub fn add_start_id(&mut self, start_id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(Edit::VT_START_ID, start_id);
  }
  #[inline]
  pub fn add_start_offset(&mut self, start_offset: u64) {
    self.fbb_.push_slot::<u64>(Edit::VT_START_OFFSET, start_offset, 0);
  }
  #[inline]
  pub fn add_end_id(&mut self, end_id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(Edit::VT_END_ID, end_id);
  }
  #[inline]
  pub fn add_end_offset(&mut self, end_offset: u64) {
    self.fbb_.push_slot::<u64>(Edit::VT_END_OFFSET, end_offset, 0);
  }
  #[inline]
  pub fn add_version_in_range(&mut self, version_in_range: flatbuffers::WIPOffset<super::GlobalTimestamp<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<super::GlobalTimestamp>>(Edit::VT_VERSION_IN_RANGE, version_in_range);
  }
  #[inline]
  pub fn add_new_text(&mut self, new_text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Edit::VT_NEW_TEXT, new_text);
  }
  #[inline]
  pub fn add_local_timestamp(&mut self, local_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(Edit::VT_LOCAL_TIMESTAMP, local_timestamp);
  }
  #[inline]
  pub fn add_lamport_timestamp(&mut self, lamport_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(Edit::VT_LAMPORT_TIMESTAMP, lamport_timestamp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EditBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EditBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Edit<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum UpdateSelectionsOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct UpdateSelections<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UpdateSelections<'a> {
    type Inner = UpdateSelections<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> UpdateSelections<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UpdateSelections {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UpdateSelectionsArgs<'args>) -> flatbuffers::WIPOffset<UpdateSelections<'bldr>> {
      let mut builder = UpdateSelectionsBuilder::new(_fbb);
      if let Some(x) = args.lamport_timestamp { builder.add_lamport_timestamp(x); }
      if let Some(x) = args.local_timestamp { builder.add_local_timestamp(x); }
      if let Some(x) = args.selections { builder.add_selections(x); }
      if let Some(x) = args.set_id { builder.add_set_id(x); }
      builder.finish()
    }

    pub const VT_SET_ID: flatbuffers::VOffsetT = 4;
    pub const VT_SELECTIONS: flatbuffers::VOffsetT = 6;
    pub const VT_LOCAL_TIMESTAMP: flatbuffers::VOffsetT = 8;
    pub const VT_LAMPORT_TIMESTAMP: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn set_id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(UpdateSelections::VT_SET_ID, None)
  }
  #[inline]
  pub fn selections(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Selection<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Selection<'a>>>>>(UpdateSelections::VT_SELECTIONS, None)
  }
  #[inline]
  pub fn local_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(UpdateSelections::VT_LOCAL_TIMESTAMP, None)
  }
  #[inline]
  pub fn lamport_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(UpdateSelections::VT_LAMPORT_TIMESTAMP, None)
  }
}

pub struct UpdateSelectionsArgs<'a> {
    pub set_id: Option<&'a  super::Timestamp>,
    pub selections: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Selection<'a >>>>>,
    pub local_timestamp: Option<&'a  super::Timestamp>,
    pub lamport_timestamp: Option<&'a  super::Timestamp>,
}
impl<'a> Default for UpdateSelectionsArgs<'a> {
    #[inline]
    fn default() -> Self {
        UpdateSelectionsArgs {
            set_id: None,
            selections: None,
            local_timestamp: None,
            lamport_timestamp: None,
        }
    }
}
pub struct UpdateSelectionsBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdateSelectionsBuilder<'a, 'b> {
  #[inline]
  pub fn add_set_id(&mut self, set_id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(UpdateSelections::VT_SET_ID, set_id);
  }
  #[inline]
  pub fn add_selections(&mut self, selections: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Selection<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateSelections::VT_SELECTIONS, selections);
  }
  #[inline]
  pub fn add_local_timestamp(&mut self, local_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(UpdateSelections::VT_LOCAL_TIMESTAMP, local_timestamp);
  }
  #[inline]
  pub fn add_lamport_timestamp(&mut self, lamport_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(UpdateSelections::VT_LAMPORT_TIMESTAMP, lamport_timestamp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdateSelectionsBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdateSelectionsBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UpdateSelections<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OperationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Operation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Operation<'a> {
    type Inner = Operation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Operation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Operation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OperationArgs) -> flatbuffers::WIPOffset<Operation<'bldr>> {
      let mut builder = OperationBuilder::new(_fbb);
      if let Some(x) = args.variant { builder.add_variant(x); }
      builder.add_variant_type(args.variant_type);
      builder.finish()
    }

    pub const VT_VARIANT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VARIANT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn variant_type(&self) -> OperationVariant {
    self._tab.get::<OperationVariant>(Operation::VT_VARIANT_TYPE, Some(OperationVariant::NONE)).unwrap()
  }
  #[inline]
  pub fn variant(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Operation::VT_VARIANT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn variant_as_edit(&'a self) -> Option<Edit> {
    if self.variant_type() == OperationVariant::Edit {
      self.variant().map(|u| Edit::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn variant_as_update_selections(&'a self) -> Option<UpdateSelections> {
    if self.variant_type() == OperationVariant::UpdateSelections {
      self.variant().map(|u| UpdateSelections::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct OperationArgs {
    pub variant_type: OperationVariant,
    pub variant: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for OperationArgs {
    #[inline]
    fn default() -> Self {
        OperationArgs {
            variant_type: OperationVariant::NONE,
            variant: None,
        }
    }
}
pub struct OperationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperationBuilder<'a, 'b> {
  #[inline]
  pub fn add_variant_type(&mut self, variant_type: OperationVariant) {
    self.fbb_.push_slot::<OperationVariant>(Operation::VT_VARIANT_TYPE, variant_type, OperationVariant::NONE);
  }
  #[inline]
  pub fn add_variant(&mut self, variant: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operation::VT_VARIANT, variant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Operation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

}  // pub mod buffer

pub mod epoch {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum FileId {
  NONE = 0,
  BaseFileId = 1,
  NewFileId = 2,

}

const ENUM_MIN_FILE_ID: u8 = 0;
const ENUM_MAX_FILE_ID: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for FileId {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FileId {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FileId;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FileId;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FileId {
    type Output = FileId;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FileId>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_FILE_ID:[FileId; 3] = [
  FileId::NONE,
  FileId::BaseFileId,
  FileId::NewFileId
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_FILE_ID:[&'static str; 3] = [
    "NONE",
    "BaseFileId",
    "NewFileId"
];

pub fn enum_name_file_id(e: FileId) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_FILE_ID[index]
}

pub struct FileIdUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(i8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum FileType {
  Directory = 0,
  Text = 1,

}

const ENUM_MIN_FILE_TYPE: i8 = 0;
const ENUM_MAX_FILE_TYPE: i8 = 1;

impl<'a> flatbuffers::Follow<'a> for FileType {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FileType {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = i8::to_le(self as i8);
    let p = &n as *const i8 as *const FileType;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = i8::from_le(self as i8);
    let p = &n as *const i8 as *const FileType;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FileType {
    type Output = FileType;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FileType>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_FILE_TYPE:[FileType; 2] = [
  FileType::Directory,
  FileType::Text
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_FILE_TYPE:[&'static str; 2] = [
    "Directory",
    "Text"
];

pub fn enum_name_file_type(e: FileType) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_FILE_TYPE[index]
}

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum Operation {
  NONE = 0,
  InsertMetadata = 1,
  UpdateParent = 2,
  BufferOperation = 3,

}

const ENUM_MIN_OPERATION: u8 = 0;
const ENUM_MAX_OPERATION: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for Operation {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Operation {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Operation;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Operation;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Operation {
    type Output = Operation;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Operation>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_OPERATION:[Operation; 4] = [
  Operation::NONE,
  Operation::InsertMetadata,
  Operation::UpdateParent,
  Operation::BufferOperation
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_OPERATION:[&'static str; 4] = [
    "NONE",
    "InsertMetadata",
    "UpdateParent",
    "BufferOperation"
];

pub fn enum_name_operation(e: Operation) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_OPERATION[index]
}

pub struct OperationUnionTableOffset {}
pub enum BaseFileIdOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BaseFileId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BaseFileId<'a> {
    type Inner = BaseFileId<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BaseFileId<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BaseFileId {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BaseFileIdArgs) -> flatbuffers::WIPOffset<BaseFileId<'bldr>> {
      let mut builder = BaseFileIdBuilder::new(_fbb);
      builder.add_index(args.index);
      builder.finish()
    }

    pub const VT_INDEX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn index(&self) -> u64 {
    self._tab.get::<u64>(BaseFileId::VT_INDEX, Some(0)).unwrap()
  }
}

pub struct BaseFileIdArgs {
    pub index: u64,
}
impl<'a> Default for BaseFileIdArgs {
    #[inline]
    fn default() -> Self {
        BaseFileIdArgs {
            index: 0,
        }
    }
}
pub struct BaseFileIdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BaseFileIdBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: u64) {
    self.fbb_.push_slot::<u64>(BaseFileId::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BaseFileIdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BaseFileIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BaseFileId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum NewFileIdOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct NewFileId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NewFileId<'a> {
    type Inner = NewFileId<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> NewFileId<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NewFileId {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NewFileIdArgs<'args>) -> flatbuffers::WIPOffset<NewFileId<'bldr>> {
      let mut builder = NewFileIdBuilder::new(_fbb);
      if let Some(x) = args.id { builder.add_id(x); }
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(NewFileId::VT_ID, None)
  }
}

pub struct NewFileIdArgs<'a> {
    pub id: Option<&'a  super::Timestamp>,
}
impl<'a> Default for NewFileIdArgs<'a> {
    #[inline]
    fn default() -> Self {
        NewFileIdArgs {
            id: None,
        }
    }
}
pub struct NewFileIdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NewFileIdBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(NewFileId::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NewFileIdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NewFileIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NewFileId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InsertMetadataOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct InsertMetadata<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for InsertMetadata<'a> {
    type Inner = InsertMetadata<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> InsertMetadata<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        InsertMetadata {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InsertMetadataArgs<'args>) -> flatbuffers::WIPOffset<InsertMetadata<'bldr>> {
      let mut builder = InsertMetadataBuilder::new(_fbb);
      if let Some(x) = args.lamport_timestamp { builder.add_lamport_timestamp(x); }
      if let Some(x) = args.local_timestamp { builder.add_local_timestamp(x); }
      if let Some(x) = args.name_in_parent { builder.add_name_in_parent(x); }
      if let Some(x) = args.parent_id { builder.add_parent_id(x); }
      if let Some(x) = args.file_id { builder.add_file_id(x); }
      builder.add_parent_id_type(args.parent_id_type);
      builder.add_file_type(args.file_type);
      builder.add_file_id_type(args.file_id_type);
      builder.finish()
    }

    pub const VT_FILE_ID_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FILE_ID: flatbuffers::VOffsetT = 6;
    pub const VT_FILE_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_PARENT_ID_TYPE: flatbuffers::VOffsetT = 10;
    pub const VT_PARENT_ID: flatbuffers::VOffsetT = 12;
    pub const VT_NAME_IN_PARENT: flatbuffers::VOffsetT = 14;
    pub const VT_LOCAL_TIMESTAMP: flatbuffers::VOffsetT = 16;
    pub const VT_LAMPORT_TIMESTAMP: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn file_id_type(&self) -> FileId {
    self._tab.get::<FileId>(InsertMetadata::VT_FILE_ID_TYPE, Some(FileId::NONE)).unwrap()
  }
  #[inline]
  pub fn file_id(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(InsertMetadata::VT_FILE_ID, None)
  }
  #[inline]
  pub fn file_type(&self) -> FileType {
    self._tab.get::<FileType>(InsertMetadata::VT_FILE_TYPE, Some(FileType::Directory)).unwrap()
  }
  #[inline]
  pub fn parent_id_type(&self) -> FileId {
    self._tab.get::<FileId>(InsertMetadata::VT_PARENT_ID_TYPE, Some(FileId::NONE)).unwrap()
  }
  #[inline]
  pub fn parent_id(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(InsertMetadata::VT_PARENT_ID, None)
  }
  #[inline]
  pub fn name_in_parent(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(InsertMetadata::VT_NAME_IN_PARENT, None)
  }
  #[inline]
  pub fn local_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(InsertMetadata::VT_LOCAL_TIMESTAMP, None)
  }
  #[inline]
  pub fn lamport_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(InsertMetadata::VT_LAMPORT_TIMESTAMP, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn file_id_as_base_file_id(&'a self) -> Option<BaseFileId> {
    if self.file_id_type() == FileId::BaseFileId {
      self.file_id().map(|u| BaseFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn file_id_as_new_file_id(&'a self) -> Option<NewFileId> {
    if self.file_id_type() == FileId::NewFileId {
      self.file_id().map(|u| NewFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parent_id_as_base_file_id(&'a self) -> Option<BaseFileId> {
    if self.parent_id_type() == FileId::BaseFileId {
      self.parent_id().map(|u| BaseFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn parent_id_as_new_file_id(&'a self) -> Option<NewFileId> {
    if self.parent_id_type() == FileId::NewFileId {
      self.parent_id().map(|u| NewFileId::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct InsertMetadataArgs<'a> {
    pub file_id_type: FileId,
    pub file_id: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub file_type: FileType,
    pub parent_id_type: FileId,
    pub parent_id: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub name_in_parent: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub local_timestamp: Option<&'a  super::Timestamp>,
    pub lamport_timestamp: Option<&'a  super::Timestamp>,
}
impl<'a> Default for InsertMetadataArgs<'a> {
    #[inline]
    fn default() -> Self {
        InsertMetadataArgs {
            file_id_type: FileId::NONE,
            file_id: None,
            file_type: FileType::Directory,
            parent_id_type: FileId::NONE,
            parent_id: None,
            name_in_parent: None,
            local_timestamp: None,
            lamport_timestamp: None,
        }
    }
}
pub struct InsertMetadataBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InsertMetadataBuilder<'a, 'b> {
  #[inline]
  pub fn add_file_id_type(&mut self, file_id_type: FileId) {
    self.fbb_.push_slot::<FileId>(InsertMetadata::VT_FILE_ID_TYPE, file_id_type, FileId::NONE);
  }
  #[inline]
  pub fn add_file_id(&mut self, file_id: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InsertMetadata::VT_FILE_ID, file_id);
  }
  #[inline]
  pub fn add_file_type(&mut self, file_type: FileType) {
    self.fbb_.push_slot::<FileType>(InsertMetadata::VT_FILE_TYPE, file_type, FileType::Directory);
  }
  #[inline]
  pub fn add_parent_id_type(&mut self, parent_id_type: FileId) {
    self.fbb_.push_slot::<FileId>(InsertMetadata::VT_PARENT_ID_TYPE, parent_id_type, FileId::NONE);
  }
  #[inline]
  pub fn add_parent_id(&mut self, parent_id: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InsertMetadata::VT_PARENT_ID, parent_id);
  }
  #[inline]
  pub fn add_name_in_parent(&mut self, name_in_parent: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(InsertMetadata::VT_NAME_IN_PARENT, name_in_parent);
  }
  #[inline]
  pub fn add_local_timestamp(&mut self, local_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(InsertMetadata::VT_LOCAL_TIMESTAMP, local_timestamp);
  }
  #[inline]
  pub fn add_lamport_timestamp(&mut self, lamport_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(InsertMetadata::VT_LAMPORT_TIMESTAMP, lamport_timestamp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InsertMetadataBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InsertMetadataBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<InsertMetadata<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum UpdateParentOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct UpdateParent<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for UpdateParent<'a> {
    type Inner = UpdateParent<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> UpdateParent<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        UpdateParent {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args UpdateParentArgs<'args>) -> flatbuffers::WIPOffset<UpdateParent<'bldr>> {
      let mut builder = UpdateParentBuilder::new(_fbb);
      if let Some(x) = args.lamport_timestamp { builder.add_lamport_timestamp(x); }
      if let Some(x) = args.local_timestamp { builder.add_local_timestamp(x); }
      if let Some(x) = args.new_name_in_parent { builder.add_new_name_in_parent(x); }
      if let Some(x) = args.new_parent_id { builder.add_new_parent_id(x); }
      if let Some(x) = args.child_id { builder.add_child_id(x); }
      builder.add_new_parent_id_type(args.new_parent_id_type);
      builder.add_child_id_type(args.child_id_type);
      builder.finish()
    }

    pub const VT_CHILD_ID_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_CHILD_ID: flatbuffers::VOffsetT = 6;
    pub const VT_NEW_PARENT_ID_TYPE: flatbuffers::VOffsetT = 8;
    pub const VT_NEW_PARENT_ID: flatbuffers::VOffsetT = 10;
    pub const VT_NEW_NAME_IN_PARENT: flatbuffers::VOffsetT = 12;
    pub const VT_LOCAL_TIMESTAMP: flatbuffers::VOffsetT = 14;
    pub const VT_LAMPORT_TIMESTAMP: flatbuffers::VOffsetT = 16;

  #[inline]
  pub fn child_id_type(&self) -> FileId {
    self._tab.get::<FileId>(UpdateParent::VT_CHILD_ID_TYPE, Some(FileId::NONE)).unwrap()
  }
  #[inline]
  pub fn child_id(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(UpdateParent::VT_CHILD_ID, None)
  }
  #[inline]
  pub fn new_parent_id_type(&self) -> FileId {
    self._tab.get::<FileId>(UpdateParent::VT_NEW_PARENT_ID_TYPE, Some(FileId::NONE)).unwrap()
  }
  #[inline]
  pub fn new_parent_id(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(UpdateParent::VT_NEW_PARENT_ID, None)
  }
  #[inline]
  pub fn new_name_in_parent(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(UpdateParent::VT_NEW_NAME_IN_PARENT, None)
  }
  #[inline]
  pub fn local_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(UpdateParent::VT_LOCAL_TIMESTAMP, None)
  }
  #[inline]
  pub fn lamport_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(UpdateParent::VT_LAMPORT_TIMESTAMP, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn child_id_as_base_file_id(&'a self) -> Option<BaseFileId> {
    if self.child_id_type() == FileId::BaseFileId {
      self.child_id().map(|u| BaseFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn child_id_as_new_file_id(&'a self) -> Option<NewFileId> {
    if self.child_id_type() == FileId::NewFileId {
      self.child_id().map(|u| NewFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_parent_id_as_base_file_id(&'a self) -> Option<BaseFileId> {
    if self.new_parent_id_type() == FileId::BaseFileId {
      self.new_parent_id().map(|u| BaseFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn new_parent_id_as_new_file_id(&'a self) -> Option<NewFileId> {
    if self.new_parent_id_type() == FileId::NewFileId {
      self.new_parent_id().map(|u| NewFileId::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct UpdateParentArgs<'a> {
    pub child_id_type: FileId,
    pub child_id: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub new_parent_id_type: FileId,
    pub new_parent_id: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub new_name_in_parent: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub local_timestamp: Option<&'a  super::Timestamp>,
    pub lamport_timestamp: Option<&'a  super::Timestamp>,
}
impl<'a> Default for UpdateParentArgs<'a> {
    #[inline]
    fn default() -> Self {
        UpdateParentArgs {
            child_id_type: FileId::NONE,
            child_id: None,
            new_parent_id_type: FileId::NONE,
            new_parent_id: None,
            new_name_in_parent: None,
            local_timestamp: None,
            lamport_timestamp: None,
        }
    }
}
pub struct UpdateParentBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> UpdateParentBuilder<'a, 'b> {
  #[inline]
  pub fn add_child_id_type(&mut self, child_id_type: FileId) {
    self.fbb_.push_slot::<FileId>(UpdateParent::VT_CHILD_ID_TYPE, child_id_type, FileId::NONE);
  }
  #[inline]
  pub fn add_child_id(&mut self, child_id: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateParent::VT_CHILD_ID, child_id);
  }
  #[inline]
  pub fn add_new_parent_id_type(&mut self, new_parent_id_type: FileId) {
    self.fbb_.push_slot::<FileId>(UpdateParent::VT_NEW_PARENT_ID_TYPE, new_parent_id_type, FileId::NONE);
  }
  #[inline]
  pub fn add_new_parent_id(&mut self, new_parent_id: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateParent::VT_NEW_PARENT_ID, new_parent_id);
  }
  #[inline]
  pub fn add_new_name_in_parent(&mut self, new_name_in_parent: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(UpdateParent::VT_NEW_NAME_IN_PARENT, new_name_in_parent);
  }
  #[inline]
  pub fn add_local_timestamp(&mut self, local_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(UpdateParent::VT_LOCAL_TIMESTAMP, local_timestamp);
  }
  #[inline]
  pub fn add_lamport_timestamp(&mut self, lamport_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(UpdateParent::VT_LAMPORT_TIMESTAMP, lamport_timestamp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> UpdateParentBuilder<'a, 'b> {
    let start = _fbb.start_table();
    UpdateParentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<UpdateParent<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BufferOperationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BufferOperation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BufferOperation<'a> {
    type Inner = BufferOperation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BufferOperation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BufferOperation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BufferOperationArgs<'args>) -> flatbuffers::WIPOffset<BufferOperation<'bldr>> {
      let mut builder = BufferOperationBuilder::new(_fbb);
      if let Some(x) = args.lamport_timestamp { builder.add_lamport_timestamp(x); }
      if let Some(x) = args.local_timestamp { builder.add_local_timestamp(x); }
      if let Some(x) = args.operations { builder.add_operations(x); }
      if let Some(x) = args.file_id { builder.add_file_id(x); }
      builder.add_file_id_type(args.file_id_type);
      builder.finish()
    }

    pub const VT_FILE_ID_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_FILE_ID: flatbuffers::VOffsetT = 6;
    pub const VT_OPERATIONS: flatbuffers::VOffsetT = 8;
    pub const VT_LOCAL_TIMESTAMP: flatbuffers::VOffsetT = 10;
    pub const VT_LAMPORT_TIMESTAMP: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn file_id_type(&self) -> FileId {
    self._tab.get::<FileId>(BufferOperation::VT_FILE_ID_TYPE, Some(FileId::NONE)).unwrap()
  }
  #[inline]
  pub fn file_id(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(BufferOperation::VT_FILE_ID, None)
  }
  #[inline]
  pub fn operations(&self) -> Option<flatbuffers::Vector<flatbuffers::ForwardsUOffset<super::buffer::Operation<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<super::buffer::Operation<'a>>>>>(BufferOperation::VT_OPERATIONS, None)
  }
  #[inline]
  pub fn local_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(BufferOperation::VT_LOCAL_TIMESTAMP, None)
  }
  #[inline]
  pub fn lamport_timestamp(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(BufferOperation::VT_LAMPORT_TIMESTAMP, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn file_id_as_base_file_id(&'a self) -> Option<BaseFileId> {
    if self.file_id_type() == FileId::BaseFileId {
      self.file_id().map(|u| BaseFileId::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn file_id_as_new_file_id(&'a self) -> Option<NewFileId> {
    if self.file_id_type() == FileId::NewFileId {
      self.file_id().map(|u| NewFileId::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct BufferOperationArgs<'a> {
    pub file_id_type: FileId,
    pub file_id: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
    pub operations: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<super::buffer::Operation<'a >>>>>,
    pub local_timestamp: Option<&'a  super::Timestamp>,
    pub lamport_timestamp: Option<&'a  super::Timestamp>,
}
impl<'a> Default for BufferOperationArgs<'a> {
    #[inline]
    fn default() -> Self {
        BufferOperationArgs {
            file_id_type: FileId::NONE,
            file_id: None,
            operations: None,
            local_timestamp: None,
            lamport_timestamp: None,
        }
    }
}
pub struct BufferOperationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BufferOperationBuilder<'a, 'b> {
  #[inline]
  pub fn add_file_id_type(&mut self, file_id_type: FileId) {
    self.fbb_.push_slot::<FileId>(BufferOperation::VT_FILE_ID_TYPE, file_id_type, FileId::NONE);
  }
  #[inline]
  pub fn add_file_id(&mut self, file_id: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BufferOperation::VT_FILE_ID, file_id);
  }
  #[inline]
  pub fn add_operations(&mut self, operations: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<super::buffer::Operation<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BufferOperation::VT_OPERATIONS, operations);
  }
  #[inline]
  pub fn add_local_timestamp(&mut self, local_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(BufferOperation::VT_LOCAL_TIMESTAMP, local_timestamp);
  }
  #[inline]
  pub fn add_lamport_timestamp(&mut self, lamport_timestamp: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(BufferOperation::VT_LAMPORT_TIMESTAMP, lamport_timestamp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BufferOperationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BufferOperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BufferOperation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

}  // pub mod epoch

pub mod worktree {
  #![allow(dead_code)]
  #![allow(unused_imports)]

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum OperationVariant {
  NONE = 0,
  StartEpoch = 1,
  EpochOperation = 2,

}

const ENUM_MIN_OPERATION_VARIANT: u8 = 0;
const ENUM_MAX_OPERATION_VARIANT: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for OperationVariant {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for OperationVariant {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const OperationVariant;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const OperationVariant;
    unsafe { *p }
  }
}

impl flatbuffers::Push for OperationVariant {
    type Output = OperationVariant;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<OperationVariant>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_OPERATION_VARIANT:[OperationVariant; 3] = [
  OperationVariant::NONE,
  OperationVariant::StartEpoch,
  OperationVariant::EpochOperation
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_OPERATION_VARIANT:[&'static str; 3] = [
    "NONE",
    "StartEpoch",
    "EpochOperation"
];

pub fn enum_name_operation_variant(e: OperationVariant) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_OPERATION_VARIANT[index]
}

pub struct OperationVariantUnionTableOffset {}
pub enum StartEpochOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct StartEpoch<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for StartEpoch<'a> {
    type Inner = StartEpoch<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> StartEpoch<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        StartEpoch {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args StartEpochArgs<'args>) -> flatbuffers::WIPOffset<StartEpoch<'bldr>> {
      let mut builder = StartEpochBuilder::new(_fbb);
      if let Some(x) = args.head { builder.add_head(x); }
      if let Some(x) = args.epoch_id { builder.add_epoch_id(x); }
      builder.finish()
    }

    pub const VT_EPOCH_ID: flatbuffers::VOffsetT = 4;
    pub const VT_HEAD: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn epoch_id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(StartEpoch::VT_EPOCH_ID, None)
  }
  #[inline]
  pub fn head(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(StartEpoch::VT_HEAD, None).map(|v| v.safe_slice())
  }
}

pub struct StartEpochArgs<'a> {
    pub epoch_id: Option<&'a  super::Timestamp>,
    pub head: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for StartEpochArgs<'a> {
    #[inline]
    fn default() -> Self {
        StartEpochArgs {
            epoch_id: None,
            head: None,
        }
    }
}
pub struct StartEpochBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> StartEpochBuilder<'a, 'b> {
  #[inline]
  pub fn add_epoch_id(&mut self, epoch_id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(StartEpoch::VT_EPOCH_ID, epoch_id);
  }
  #[inline]
  pub fn add_head(&mut self, head: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(StartEpoch::VT_HEAD, head);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> StartEpochBuilder<'a, 'b> {
    let start = _fbb.start_table();
    StartEpochBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<StartEpoch<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum EpochOperationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct EpochOperation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for EpochOperation<'a> {
    type Inner = EpochOperation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> EpochOperation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        EpochOperation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args EpochOperationArgs<'args>) -> flatbuffers::WIPOffset<EpochOperation<'bldr>> {
      let mut builder = EpochOperationBuilder::new(_fbb);
      if let Some(x) = args.operation { builder.add_operation(x); }
      if let Some(x) = args.epoch_id { builder.add_epoch_id(x); }
      builder.add_operation_type(args.operation_type);
      builder.finish()
    }

    pub const VT_EPOCH_ID: flatbuffers::VOffsetT = 4;
    pub const VT_OPERATION_TYPE: flatbuffers::VOffsetT = 6;
    pub const VT_OPERATION: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn epoch_id(&self) -> Option<&'a super::Timestamp> {
    self._tab.get::<super::Timestamp>(EpochOperation::VT_EPOCH_ID, None)
  }
  #[inline]
  pub fn operation_type(&self) -> super::epoch::Operation {
    self._tab.get::<super::epoch::Operation>(EpochOperation::VT_OPERATION_TYPE, Some(super::epoch::Operation::NONE)).unwrap()
  }
  #[inline]
  pub fn operation(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(EpochOperation::VT_OPERATION, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn operation_as_insert_metadata(&'a self) -> Option<super::epoch::InsertMetadata> {
    if self.operation_type() == super::epoch::Operation::InsertMetadata {
      self.operation().map(|u| super::epoch::InsertMetadata::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn operation_as_update_parent(&'a self) -> Option<super::epoch::UpdateParent> {
    if self.operation_type() == super::epoch::Operation::UpdateParent {
      self.operation().map(|u| super::epoch::UpdateParent::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn operation_as_buffer_operation(&'a self) -> Option<super::epoch::BufferOperation> {
    if self.operation_type() == super::epoch::Operation::BufferOperation {
      self.operation().map(|u| super::epoch::BufferOperation::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct EpochOperationArgs<'a> {
    pub epoch_id: Option<&'a  super::Timestamp>,
    pub operation_type: super::epoch::Operation,
    pub operation: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for EpochOperationArgs<'a> {
    #[inline]
    fn default() -> Self {
        EpochOperationArgs {
            epoch_id: None,
            operation_type: super::epoch::Operation::NONE,
            operation: None,
        }
    }
}
pub struct EpochOperationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> EpochOperationBuilder<'a, 'b> {
  #[inline]
  pub fn add_epoch_id(&mut self, epoch_id: &'b  super::Timestamp) {
    self.fbb_.push_slot_always::<&super::Timestamp>(EpochOperation::VT_EPOCH_ID, epoch_id);
  }
  #[inline]
  pub fn add_operation_type(&mut self, operation_type: super::epoch::Operation) {
    self.fbb_.push_slot::<super::epoch::Operation>(EpochOperation::VT_OPERATION_TYPE, operation_type, super::epoch::Operation::NONE);
  }
  #[inline]
  pub fn add_operation(&mut self, operation: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(EpochOperation::VT_OPERATION, operation);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> EpochOperationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    EpochOperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<EpochOperation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum OperationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Operation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Operation<'a> {
    type Inner = Operation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Operation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Operation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args OperationArgs) -> flatbuffers::WIPOffset<Operation<'bldr>> {
      let mut builder = OperationBuilder::new(_fbb);
      if let Some(x) = args.variant { builder.add_variant(x); }
      builder.add_variant_type(args.variant_type);
      builder.finish()
    }

    pub const VT_VARIANT_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_VARIANT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn variant_type(&self) -> OperationVariant {
    self._tab.get::<OperationVariant>(Operation::VT_VARIANT_TYPE, Some(OperationVariant::NONE)).unwrap()
  }
  #[inline]
  pub fn variant(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Operation::VT_VARIANT, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn variant_as_start_epoch(&'a self) -> Option<StartEpoch> {
    if self.variant_type() == OperationVariant::StartEpoch {
      self.variant().map(|u| StartEpoch::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn variant_as_epoch_operation(&'a self) -> Option<EpochOperation> {
    if self.variant_type() == OperationVariant::EpochOperation {
      self.variant().map(|u| EpochOperation::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct OperationArgs {
    pub variant_type: OperationVariant,
    pub variant: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for OperationArgs {
    #[inline]
    fn default() -> Self {
        OperationArgs {
            variant_type: OperationVariant::NONE,
            variant: None,
        }
    }
}
pub struct OperationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> OperationBuilder<'a, 'b> {
  #[inline]
  pub fn add_variant_type(&mut self, variant_type: OperationVariant) {
    self.fbb_.push_slot::<OperationVariant>(Operation::VT_VARIANT_TYPE, variant_type, OperationVariant::NONE);
  }
  #[inline]
  pub fn add_variant(&mut self, variant: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Operation::VT_VARIANT, variant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> OperationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    OperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Operation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_operation<'a>(buf: &'a [u8]) -> Operation<'a> {
  flatbuffers::get_root::<Operation<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_operation<'a>(buf: &'a [u8]) -> Operation<'a> {
  flatbuffers::get_size_prefixed_root::<Operation<'a>>(buf)
}

#[inline]
pub fn finish_operation_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Operation<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_operation_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Operation<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
}  // pub mod worktree

use flatbuffers::EndianScalar;
