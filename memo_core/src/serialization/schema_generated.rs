// automatically generated by the FlatBuffers compiler, do not modify


#![allow(dead_code)]
#![allow(unused_imports)]
extern crate flatbuffers;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Debug)]
pub enum FileId {
  NONE = 0,
  BaseFileId = 1,
  NewFileId = 2,

}

const ENUM_MIN_FILE_ID: u8 = 0;
const ENUM_MAX_FILE_ID: u8 = 2;

impl<'a> flatbuffers::Follow<'a> for FileId {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for FileId {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const FileId;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const FileId;
    unsafe { *p }
  }
}

impl flatbuffers::Push for FileId {
    type Output = FileId;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<FileId>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_FILE_ID:[FileId; 3] = [
  FileId::NONE,
  FileId::BaseFileId,
  FileId::NewFileId
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_FILE_ID:[&'static str; 3] = [
    "NONE",
    "BaseFileId",
    "NewFileId"
];

pub fn enum_name_file_id(e: FileId) -> &'static str {
  let index: usize = e as usize;
  ENUM_NAMES_FILE_ID[index]
}

pub struct FileIdUnionTableOffset {}
// struct ReplicaId, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct ReplicaId {
  a_: u64,
  b_: u64,
  c_: u64,
  d_: u64,
} // pub struct ReplicaId
impl flatbuffers::SafeSliceAccess for ReplicaId {}
impl<'a> flatbuffers::Follow<'a> for ReplicaId {
  type Inner = &'a ReplicaId;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a ReplicaId>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a ReplicaId {
  type Inner = &'a ReplicaId;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<ReplicaId>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for ReplicaId {
    type Output = ReplicaId;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const ReplicaId as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b ReplicaId {
    type Output = ReplicaId;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const ReplicaId as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl ReplicaId {
  pub fn new<'a>(_a: u64, _b: u64, _c: u64, _d: u64) -> Self {
    ReplicaId {
      a_: _a.to_little_endian(),
      b_: _b.to_little_endian(),
      c_: _c.to_little_endian(),
      d_: _d.to_little_endian(),

    }
  }
  pub fn a<'a>(&'a self) -> u64 {
    self.a_.from_little_endian()
  }
  pub fn b<'a>(&'a self) -> u64 {
    self.b_.from_little_endian()
  }
  pub fn c<'a>(&'a self) -> u64 {
    self.c_.from_little_endian()
  }
  pub fn d<'a>(&'a self) -> u64 {
    self.d_.from_little_endian()
  }
}

// struct Timestamp, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Timestamp {
  value_: u64,
  replica_id_: ReplicaId,
} // pub struct Timestamp
impl flatbuffers::SafeSliceAccess for Timestamp {}
impl<'a> flatbuffers::Follow<'a> for Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Timestamp>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Timestamp {
  type Inner = &'a Timestamp;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Timestamp>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Timestamp {
    type Output = Timestamp;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Timestamp {
    type Output = Timestamp;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Timestamp as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Timestamp {
  pub fn new<'a>(_value: u64, _replica_id: &'a ReplicaId) -> Self {
    Timestamp {
      value_: _value.to_little_endian(),
      replica_id_: *_replica_id,

    }
  }
  pub fn value<'a>(&'a self) -> u64 {
    self.value_.from_little_endian()
  }
  pub fn replica_id<'a>(&'a self) -> &'a ReplicaId {
    &self.replica_id_
  }
}

pub enum GlobalTimestampOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GlobalTimestamp<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GlobalTimestamp<'a> {
    type Inner = GlobalTimestamp<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GlobalTimestamp<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GlobalTimestamp {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GlobalTimestampArgs<'args>) -> flatbuffers::WIPOffset<GlobalTimestamp<'bldr>> {
      let mut builder = GlobalTimestampBuilder::new(_fbb);
      if let Some(x) = args.timestamps { builder.add_timestamps(x); }
      builder.finish()
    }

    pub const VT_TIMESTAMPS: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn timestamps(&self) -> Option<&'a [Timestamp]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Timestamp>>>(GlobalTimestamp::VT_TIMESTAMPS, None).map(|v| v.safe_slice() )
  }
}

pub struct GlobalTimestampArgs<'a> {
    pub timestamps: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Timestamp>>>,
}
impl<'a> Default for GlobalTimestampArgs<'a> {
    #[inline]
    fn default() -> Self {
        GlobalTimestampArgs {
            timestamps: None,
        }
    }
}
pub struct GlobalTimestampBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GlobalTimestampBuilder<'a, 'b> {
  #[inline]
  pub fn add_timestamps(&mut self, timestamps: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Timestamp>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GlobalTimestamp::VT_TIMESTAMPS, timestamps);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GlobalTimestampBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GlobalTimestampBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GlobalTimestamp<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BaseFileIdOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BaseFileId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BaseFileId<'a> {
    type Inner = BaseFileId<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BaseFileId<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BaseFileId {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BaseFileIdArgs) -> flatbuffers::WIPOffset<BaseFileId<'bldr>> {
      let mut builder = BaseFileIdBuilder::new(_fbb);
      builder.add_index(args.index);
      builder.finish()
    }

    pub const VT_INDEX: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn index(&self) -> u64 {
    self._tab.get::<u64>(BaseFileId::VT_INDEX, Some(0)).unwrap()
  }
}

pub struct BaseFileIdArgs {
    pub index: u64,
}
impl<'a> Default for BaseFileIdArgs {
    #[inline]
    fn default() -> Self {
        BaseFileIdArgs {
            index: 0,
        }
    }
}
pub struct BaseFileIdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BaseFileIdBuilder<'a, 'b> {
  #[inline]
  pub fn add_index(&mut self, index: u64) {
    self.fbb_.push_slot::<u64>(BaseFileId::VT_INDEX, index, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BaseFileIdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BaseFileIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BaseFileId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum NewFileIdOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct NewFileId<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for NewFileId<'a> {
    type Inner = NewFileId<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> NewFileId<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        NewFileId {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args NewFileIdArgs<'args>) -> flatbuffers::WIPOffset<NewFileId<'bldr>> {
      let mut builder = NewFileIdBuilder::new(_fbb);
      if let Some(x) = args.id { builder.add_id(x); }
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn id(&self) -> Option<&'a Timestamp> {
    self._tab.get::<Timestamp>(NewFileId::VT_ID, None)
  }
}

pub struct NewFileIdArgs<'a> {
    pub id: Option<&'a  Timestamp>,
}
impl<'a> Default for NewFileIdArgs<'a> {
    #[inline]
    fn default() -> Self {
        NewFileIdArgs {
            id: None,
        }
    }
}
pub struct NewFileIdBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> NewFileIdBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: &'b  Timestamp) {
    self.fbb_.push_slot_always::<&Timestamp>(NewFileId::VT_ID, id);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> NewFileIdBuilder<'a, 'b> {
    let start = _fbb.start_table();
    NewFileIdBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<NewFileId<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum BufferOperationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct BufferOperation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for BufferOperation<'a> {
    type Inner = BufferOperation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> BufferOperation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        BufferOperation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args BufferOperationArgs<'args>) -> flatbuffers::WIPOffset<BufferOperation<'bldr>> {
      let mut builder = BufferOperationBuilder::new(_fbb);
      builder.add_end_offset(args.end_offset);
      builder.add_start_offset(args.start_offset);
      if let Some(x) = args.lamport_timestamp { builder.add_lamport_timestamp(x); }
      if let Some(x) = args.local_timestamp { builder.add_local_timestamp(x); }
      if let Some(x) = args.new_text { builder.add_new_text(x); }
      if let Some(x) = args.version_in_range { builder.add_version_in_range(x); }
      if let Some(x) = args.end_id { builder.add_end_id(x); }
      if let Some(x) = args.start_id { builder.add_start_id(x); }
      builder.finish()
    }

    pub const VT_START_ID: flatbuffers::VOffsetT = 4;
    pub const VT_START_OFFSET: flatbuffers::VOffsetT = 6;
    pub const VT_END_ID: flatbuffers::VOffsetT = 8;
    pub const VT_END_OFFSET: flatbuffers::VOffsetT = 10;
    pub const VT_VERSION_IN_RANGE: flatbuffers::VOffsetT = 12;
    pub const VT_NEW_TEXT: flatbuffers::VOffsetT = 14;
    pub const VT_LOCAL_TIMESTAMP: flatbuffers::VOffsetT = 16;
    pub const VT_LAMPORT_TIMESTAMP: flatbuffers::VOffsetT = 18;

  #[inline]
  pub fn start_id(&self) -> Option<&'a Timestamp> {
    self._tab.get::<Timestamp>(BufferOperation::VT_START_ID, None)
  }
  #[inline]
  pub fn start_offset(&self) -> u64 {
    self._tab.get::<u64>(BufferOperation::VT_START_OFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn end_id(&self) -> Option<&'a Timestamp> {
    self._tab.get::<Timestamp>(BufferOperation::VT_END_ID, None)
  }
  #[inline]
  pub fn end_offset(&self) -> u64 {
    self._tab.get::<u64>(BufferOperation::VT_END_OFFSET, Some(0)).unwrap()
  }
  #[inline]
  pub fn version_in_range(&self) -> Option<GlobalTimestamp<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<GlobalTimestamp<'a>>>(BufferOperation::VT_VERSION_IN_RANGE, None)
  }
  #[inline]
  pub fn new_text(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(BufferOperation::VT_NEW_TEXT, None)
  }
  #[inline]
  pub fn local_timestamp(&self) -> Option<&'a Timestamp> {
    self._tab.get::<Timestamp>(BufferOperation::VT_LOCAL_TIMESTAMP, None)
  }
  #[inline]
  pub fn lamport_timestamp(&self) -> Option<&'a Timestamp> {
    self._tab.get::<Timestamp>(BufferOperation::VT_LAMPORT_TIMESTAMP, None)
  }
}

pub struct BufferOperationArgs<'a> {
    pub start_id: Option<&'a  Timestamp>,
    pub start_offset: u64,
    pub end_id: Option<&'a  Timestamp>,
    pub end_offset: u64,
    pub version_in_range: Option<flatbuffers::WIPOffset<GlobalTimestamp<'a >>>,
    pub new_text: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub local_timestamp: Option<&'a  Timestamp>,
    pub lamport_timestamp: Option<&'a  Timestamp>,
}
impl<'a> Default for BufferOperationArgs<'a> {
    #[inline]
    fn default() -> Self {
        BufferOperationArgs {
            start_id: None,
            start_offset: 0,
            end_id: None,
            end_offset: 0,
            version_in_range: None,
            new_text: None,
            local_timestamp: None,
            lamport_timestamp: None,
        }
    }
}
pub struct BufferOperationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> BufferOperationBuilder<'a, 'b> {
  #[inline]
  pub fn add_start_id(&mut self, start_id: &'b  Timestamp) {
    self.fbb_.push_slot_always::<&Timestamp>(BufferOperation::VT_START_ID, start_id);
  }
  #[inline]
  pub fn add_start_offset(&mut self, start_offset: u64) {
    self.fbb_.push_slot::<u64>(BufferOperation::VT_START_OFFSET, start_offset, 0);
  }
  #[inline]
  pub fn add_end_id(&mut self, end_id: &'b  Timestamp) {
    self.fbb_.push_slot_always::<&Timestamp>(BufferOperation::VT_END_ID, end_id);
  }
  #[inline]
  pub fn add_end_offset(&mut self, end_offset: u64) {
    self.fbb_.push_slot::<u64>(BufferOperation::VT_END_OFFSET, end_offset, 0);
  }
  #[inline]
  pub fn add_version_in_range(&mut self, version_in_range: flatbuffers::WIPOffset<GlobalTimestamp<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<GlobalTimestamp>>(BufferOperation::VT_VERSION_IN_RANGE, version_in_range);
  }
  #[inline]
  pub fn add_new_text(&mut self, new_text: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(BufferOperation::VT_NEW_TEXT, new_text);
  }
  #[inline]
  pub fn add_local_timestamp(&mut self, local_timestamp: &'b  Timestamp) {
    self.fbb_.push_slot_always::<&Timestamp>(BufferOperation::VT_LOCAL_TIMESTAMP, local_timestamp);
  }
  #[inline]
  pub fn add_lamport_timestamp(&mut self, lamport_timestamp: &'b  Timestamp) {
    self.fbb_.push_slot_always::<&Timestamp>(BufferOperation::VT_LAMPORT_TIMESTAMP, lamport_timestamp);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> BufferOperationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    BufferOperationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<BufferOperation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_buffer_operation<'a>(buf: &'a [u8]) -> BufferOperation<'a> {
  flatbuffers::get_root::<BufferOperation<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_buffer_operation<'a>(buf: &'a [u8]) -> BufferOperation<'a> {
  flatbuffers::get_size_prefixed_root::<BufferOperation<'a>>(buf)
}

#[inline]
pub fn finish_buffer_operation_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<BufferOperation<'a>>) {
  fbb.finish(root, None);
}

#[inline]
pub fn finish_size_prefixed_buffer_operation_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<BufferOperation<'a>>) {
  fbb.finish_size_prefixed(root, None);
}
use flatbuffers::EndianScalar;
